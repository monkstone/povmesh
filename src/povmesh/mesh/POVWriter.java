/*
 * This library adds PovRAY export facility to toxiclibscore
 * Copyright (c) 2012 Martin Prout
 *
 * This library is free software; you can redistribute it and/or modify it under
 * the terms of the GNU Lesser General Public License as published by the Free
 * Software Foundation; either version 2.1 of the License, or (at your option)
 * any later version.
 *
 * http://creativecommons.org/licenses/LGPL/2.1/
 *
 * This library is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
 * details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library; if not, write to the Free Software Foundation, Inc.,
 * 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
 */
package povmesh.mesh;

import java.io.PrintWriter;
import toxi.geom.Vec3D;

/**
 * Extremely bare bones PovRAY 3D format exporter. Purely handles the writing of
 * data to the .inc file, as a mesh2 object. See {@link TriangleMesh} for
 * details. Logic heavily borrowed from toxis STL/obj writer, but adjusted for
 * PovRAY and external use
 *
 * @see TriangleMesh#saveAsPOV(povWriter)
 */
public class POVWriter implements POVInterface {

    final String COMMA = ", ";
    /**
     *
     */
    public final String VERSION = "0.5";
    /**
     *
     */
    protected PrintWriter povWriter;
    /**
     * Track the number of vertices written to file
     */
    protected int numVerticesWritten = 0;
    /**
     * Track the number of normals written to file
     */
    protected int numNormalsWritten = 0;
    private Options opt;

    /**
     * Handles PrintWriter input
     *
     * @param pw
     */
    public POVWriter(PrintWriter pw) {
        this.opt = Options.RAW;
        povWriter = pw;
        handleBeginSave();
    }

    /**
     * Handles PrintWriter input
     *
     * @param pw
     * @param opt
     */
    public POVWriter(PrintWriter pw, Options opt) {
        this.opt = opt;
        povWriter = pw;
        handleBeginSave();
    }

    /**
     * close the mesh declaration
     */
    @Override
    public void endSave() {
        switch (opt) {
            case GLASS:
                povWriter.println(TextureBuilder.getRCTrans());
                povWriter.println(TextureBuilder.FINISH5);
                break;
            case METAL:
                povWriter.println(TextureBuilder.getRCOpaque());
                povWriter.println(TextureBuilder.MFINISHE);
                break;
            case PHONG:
                povWriter.println(TextureBuilder.getRCOpaque());
                povWriter.println(TextureBuilder.PHONG);
                break;
            case RED:
                povWriter.println(TextureBuilder.getRed());
                povWriter.println(TextureBuilder.PHONG);
                break;
            case WHITE:
                povWriter.println(TextureBuilder.getWhite());
                povWriter.println(TextureBuilder.PHONG);
                break;
            case RANDOM:
                povWriter.println(TextureBuilder.getRandRCTrans());
                povWriter.println(TextureBuilder.FINISH5);
                break;
            case TWOTONE:
                povWriter.println(TextureBuilder.getTwoTone());
                povWriter.println(TextureBuilder.PHONG);
                break;
            default:
                break;
        }
        povWriter.println("}"); // end of mesh2 declaration
    }

    /**
     * Write face indices as as vector
     *
     * @param a
     * @param b
     * @param c
     */
    @Override
    public void face(int a, int b, int c) {
        povWriter.println(buildVector(a, b, c));
    }

    /**
     * Track the number of normals written to file
     *
     * @return
     */
    @Override
    public int getCurrNormalOffset() {
        return numNormalsWritten;
    }

    /**
     * Track the number of vertices written to file
     *
     * @return
     */
    @Override
    public int getCurrVertexOffset() {
        return numVerticesWritten;
    }

    /**
     * Print a header, and initialise counts
     */
    protected final void handleBeginSave() {
        povWriter.println("// generated by POVExport v" + VERSION);
        switch (opt) {
            case GLASS:
            case RANDOM:
                povWriter.println(TextureBuilder.declareRCTrans());
                povWriter.println(TextureBuilder.DFINISH5);
                break;
            case METAL:
                povWriter.println(TextureBuilder.declareRCOpaque());
                povWriter.println(TextureBuilder.DMFINISHE);
                break;
            case PHONG:
                povWriter.println(TextureBuilder.declareRCOpaque());
                povWriter.println(TextureBuilder.DPHONG);
                break;
            case RED:
            case TWOTONE:
            case WHITE:
                povWriter.println(TextureBuilder.DPHONG);
                break;
            default:
                break;
        }
    }

    /**
     * Begin the mesh2 output as a PovRAY declaration
     *
     * @param name
     */
    @Override
    public void beginMesh2(String name) {
        numVerticesWritten = 0;
        numNormalsWritten = 0;
        StringBuilder pov = new StringBuilder("mesh2{\n");
        pov.append(String.format("/** %s */\n", name));
        pov.append("\tvertex_vectors {");
        povWriter.println(pov);
    }

    /**
     * End the current section ie vertex_vector, normal_vector or face_indices
     */
    @Override
    public void endSection() {
        povWriter.println("\t}");
    }

    /**
     * Output start of normal_vectors
     *
     * @param count
     */
    @Override
    public void beginNormals(int count) {
        povWriter.println("\tnormal_vectors{");
        total(count);
    }

    /**
     * Output start of face_indices
     *
     * @param count
     */
    @Override
    public void beginIndices(int count) {
        povWriter.println("\tface_indices{");
        total(count);
    }

    /**
     * Used to output total count vertex_vector, normal_vector & face_indices
     *
     * @param count
     */
    @Override
    public void total(int count) {
        povWriter.println(String.format("\t%d,", count));
    }

    /**
     * Write normal as PovRAY vector
     *
     * @param n
     */
    @Override
    public void normal(Vec3D n) {
        povWriter.println(buildVector(n));
        numNormalsWritten++;
    }

    /**
     * Write vertex as PovRAY vector
     *
     * @param v
     */
    @Override
    public void vertex(Vec3D v) {
        povWriter.println(buildVector(v));
        numVerticesWritten++;
    }

    /**
     * This version is strictly for scale, translate and rotate
     *
     * @param a
     * @param b
     * @param c
     * @return povray vector (floats)
     */
    private StringBuilder buildVector(float a, float b, float c) {
        StringBuilder my_vector = new StringBuilder(120);
        my_vector.append('<');
        my_vector.append(a).append(COMMA);
        my_vector.append(b).append(COMMA);
        return my_vector.append(c).append('>');
    }

    /**
     * This version is strictly for face indices (possibly normals/uv)
     *
     * @param a
     * @param b
     * @param c
     * @return povray vector (integers)
     */
    private StringBuilder buildVector(int a, int b, int c) {
        StringBuilder my_vector = new StringBuilder(120);
        my_vector.append('\t').append('<');
        my_vector.append(a).append(COMMA);
        my_vector.append(b).append(COMMA);
        my_vector.append(c).append('>');
        return my_vector.append(COMMA);
    }

    /**
     * The Y and Z coordinates are multiplied by -1 to handle the conversion of
     * processing coordinate system to PovRAY coordinate system.
     *
     * @param v
     * @return povray vector
     */
    private StringBuilder buildVector(Vec3D v) {
        StringBuilder my_vector = new StringBuilder(120);
        my_vector.append('\t').append('<');
        my_vector.append(v.x).append(COMMA);
        my_vector.append(v.y * -1).append(COMMA);
        my_vector.append(v.z * -1).append('>');
        return my_vector.append(COMMA);
    }

    void beginForeground() {
        povWriter.append("#declare mesh_objects = union {\n");
    }

    void endForeground() {
        povWriter.append("rotate");
        povWriter.append(buildVector(0.0f, 15.0f, 0.0f));
        povWriter.append('\n');
        povWriter.append("scale");
        povWriter.append(buildVector(0.5f, 0.5f, 0.5f));
        povWriter.append('\n');
        povWriter.append("translate");
        povWriter.append(buildVector(0.0f, 0.0f, 0.0f));
        povWriter.append('\n');
        povWriter.append("}\n");
    }
}
